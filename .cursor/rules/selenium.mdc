# Selenium + Railwayæœ€é©åŒ–ãƒ«ãƒ¼ãƒ«

## ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠæŒ‡é‡

### æ¨å¥¨ãƒ‘ã‚¿ãƒ¼ãƒ³: Browserless Remote Driver

**Railwayä¸Šã§ã®Seleniumå®Ÿè¡Œã«ãŠã„ã¦æœ€ã‚‚æ¨å¥¨ã•ã‚Œã‚‹æ–¹æ³•**

#### åˆ©ç”¨å ´é¢
- ğŸ¯ **æœ¬ç•ªç’°å¢ƒã§ã®å®‰å®šå‹•ä½œãŒå¿…è¦**
- ğŸ¯ **ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹è² è·ã‚’æœ€å°åŒ–ã—ãŸã„**
- ğŸ¯ **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ãŒå¿…è¦**
- ğŸ¯ **ãƒ‡ãƒãƒƒã‚°ãƒ„ãƒ¼ãƒ«ãŒæ¬²ã—ã„**

#### å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³
```python
import os
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities

def setup_browserless_driver() -> webdriver.Remote:
    """Browserless remote driverã®è¨­å®š"""
    options = Options()
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--disable-gpu")
    
    capabilities = DesiredCapabilities.CHROME
    capabilities['browserless:token'] = os.environ.get('BROWSERLESS_TOKEN')
    
    driver = webdriver.Remote(
        command_executor="https://chrome.browserless.io/webdriver",
        options=options,
        desired_capabilities=capabilities
    )
    return driver

def scrape_with_browserless(url: str) -> dict[str, str]:
    """Browserlessã‚’ä½¿ç”¨ã—ãŸã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°"""
    driver = None
    try:
        driver = setup_browserless_driver()
        driver.get(url)
        
        # ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°å‡¦ç†
        title = driver.title
        
        return {"status": "success", "title": title, "url": url}
        
    except Exception as e:
        return {"status": "error", "error": str(e), "url": url}
    finally:
        if driver:
            driver.quit()
```

### ä»£æ›¿ãƒ‘ã‚¿ãƒ¼ãƒ³: åŒä¸€ã‚³ãƒ³ãƒ†ãƒŠå®Ÿè¡Œ

**ã‚³ã‚¹ãƒˆé‡è¦–ã¾ãŸã¯å¤–éƒ¨ä¾å­˜ã‚’é¿ã‘ãŸã„å ´åˆ**

#### åˆ©ç”¨å ´é¢
- ğŸ’° **ã‚³ã‚¹ãƒˆæœ€å„ªå…ˆ**
- ğŸ”’ **å¤–éƒ¨ä¾å­˜ã‚’é¿ã‘ãŸã„**
- ğŸ“Š **è»½é‡ãªã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°**

#### Dockerè¨­å®š
```dockerfile
# Multi-stage build for optimization
FROM ghcr.io/astral-sh/uv:python3.12-bookworm-slim AS builder

# Install Chrome and ChromeDriver
RUN apt-get update && apt-get install -y \
    wget gnupg unzip curl && \
    wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add - && \
    echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google.list && \
    apt-get update && \
    apt-get install -y google-chrome-stable && \
    rm -rf /var/lib/apt/lists/*

# Install ChromeDriver
RUN CHROMEDRIVER_VERSION=$(curl -sS chromedriver.storage.googleapis.com/LATEST_RELEASE) && \
    wget -N http://chromedriver.storage.googleapis.com/$CHROMEDRIVER_VERSION/chromedriver_linux64.zip && \
    unzip chromedriver_linux64.zip && \
    chmod +x chromedriver && \
    mv chromedriver /usr/local/bin/ && \
    rm chromedriver_linux64.zip

FROM builder AS production

# Environment variables
ENV PYTHONUNBUFFERED=1
ENV UV_COMPILE_BYTECODE=1
ENV DISPLAY=:99

# Create non-root user
RUN groupadd --gid 1000 appuser && \
    useradd --uid 1000 --gid 1000 --create-home appuser

WORKDIR /app
COPY pyproject.toml uv.lock ./
RUN uv sync --frozen --no-cache

COPY --chown=appuser:appuser src/ ./src/
USER appuser

CMD ["uv", "run", "app"]
```

#### å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³
```python
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service

def setup_local_driver() -> webdriver.Chrome:
    """ãƒ­ãƒ¼ã‚«ãƒ«Chrome driverã®è¨­å®š"""
    options = Options()
    options.add_argument("--headless")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--disable-gpu")
    options.add_argument("--remote-debugging-port=9222")
    
    service = Service("/usr/local/bin/chromedriver")
    
    driver = webdriver.Chrome(service=service, options=options)
    return driver

def scrape_with_local_driver(url: str) -> dict[str, str]:
    """ãƒ­ãƒ¼ã‚«ãƒ«driverã‚’ä½¿ç”¨ã—ãŸã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°"""
    driver = None
    try:
        driver = setup_local_driver()
        driver.get(url)
        
        title = driver.title
        
        return {"status": "success", "title": title, "url": url}
        
    except Exception as e:
        return {"status": "error", "error": str(e), "url": url}
    finally:
        if driver:
            driver.quit()
```

## Railwayè¨­å®š

### railway.tomlè¨­å®š

```toml
[build]
builder = "DOCKERFILE"
dockerfilePath = "Dockerfile"

[deploy]
restartPolicyType = "ON_FAILURE"
sleepApplication = false
# å¿…è¦ã«å¿œã˜ã¦ãƒªã‚½ãƒ¼ã‚¹åˆ¶é™
startCommand = "uv run app"

# Browserlessä½¿ç”¨æ™‚ã®ç’°å¢ƒå¤‰æ•°
[[deploy.environmentVariables]]
name = "BROWSERLESS_TOKEN"
value = "${{BROWSERLESS_TOKEN}}"

[[deploy.environmentVariables]]
name = "ENVIRONMENT"
value = "production"
```

### ç’°å¢ƒå¤‰æ•°ç®¡ç†

```bash
# Browserlessä½¿ç”¨æ™‚
railway variables set BROWSERLESS_TOKEN="your-browserless-token"
railway variables set BROWSERLESS_ENDPOINT="https://chrome.browserless.io"

# åŒä¸€ã‚³ãƒ³ãƒ†ãƒŠä½¿ç”¨æ™‚
railway variables set CHROME_DRIVER_PATH="/usr/local/bin/chromedriver"
railway variables set DISPLAY=":99"
```

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### Browserlessæœ€é©åŒ–

```python
import asyncio
from typing import List, Dict, Any
from concurrent.futures import ThreadPoolExecutor

class BrowserlessScrapingPool:
    """Browserlessç”¨ä¸¦åˆ—ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ãƒ—ãƒ¼ãƒ«"""
    
    def __init__(self, max_workers: int = 5):
        self.max_workers = max_workers
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    def scrape_urls(self, urls: List[str]) -> List[Dict[str, Any]]:
        """è¤‡æ•°URLã®ä¸¦åˆ—ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°"""
        futures = [
            self.executor.submit(scrape_with_browserless, url) 
            for url in urls
        ]
        
        results = []
        for future in futures:
            try:
                result = future.result(timeout=30)
                results.append(result)
            except Exception as e:
                results.append({
                    "status": "error", 
                    "error": f"Timeout or error: {e}"
                })
        
        return results
```

### ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†

```python
from contextlib import contextmanager
from typing import Generator

@contextmanager
def managed_driver(driver_type: str = "browserless") -> Generator[webdriver.Remote, None, None]:
    """ãƒ‰ãƒ©ã‚¤ãƒãƒ¼ã®ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†"""
    driver = None
    try:
        if driver_type == "browserless":
            driver = setup_browserless_driver()
        else:
            driver = setup_local_driver()
        
        yield driver
        
    except Exception as e:
        logger.error(f"Driver error: {e}")
        raise
    finally:
        if driver:
            try:
                driver.quit()
            except Exception as e:
                logger.warning(f"Driver cleanup error: {e}")

# ä½¿ç”¨ä¾‹
def safe_scraping(url: str) -> dict[str, str]:
    """å®‰å…¨ãªã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°å®Ÿè¡Œ"""
    with managed_driver("browserless") as driver:
        driver.get(url)
        return {"title": driver.title, "url": url}
```

## ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

### å …ç‰¢ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

```python
import time
from typing import Optional, Callable
from selenium.common.exceptions import (
    WebDriverException, 
    TimeoutException, 
    NoSuchElementException
)

def retry_on_failure(
    func: Callable, 
    max_retries: int = 3, 
    delay: float = 1.0
) -> Optional[dict]:
    """ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°å‡¦ç†ã®ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½"""
    
    for attempt in range(max_retries):
        try:
            return func()
            
        except (WebDriverException, TimeoutException) as e:
            logger.warning(f"Attempt {attempt + 1} failed: {e}")
            
            if attempt < max_retries - 1:
                time.sleep(delay * (2 ** attempt))  # Exponential backoff
                continue
            else:
                logger.error(f"All {max_retries} attempts failed")
                return {"status": "error", "error": str(e)}
                
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            return {"status": "error", "error": str(e)}

# ä½¿ç”¨ä¾‹
def robust_scraping(url: str) -> dict[str, str]:
    """å …ç‰¢ãªã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°"""
    return retry_on_failure(
        lambda: scrape_with_browserless(url),
        max_retries=3
    )
```

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### Browserlessãƒ†ã‚¹ãƒˆ

```python
import pytest
from unittest.mock import Mock, patch

@pytest.fixture
def mock_browserless_driver():
    """Browserless driver ã®ãƒ¢ãƒƒã‚¯"""
    with patch("selenium.webdriver.Remote") as mock_driver:
        mock_instance = Mock()
        mock_driver.return_value = mock_instance
        yield mock_instance

def test_browserless_scraping_success(mock_browserless_driver):
    """Browserlessã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°æˆåŠŸãƒ†ã‚¹ãƒˆ"""
    # Arrange
    mock_browserless_driver.title = "Test Title"
    
    # Act
    result = scrape_with_browserless("https://example.com")
    
    # Assert
    assert result["status"] == "success"
    assert result["title"] == "Test Title"
    mock_browserless_driver.get.assert_called_once_with("https://example.com")
    mock_browserless_driver.quit.assert_called_once()

@pytest.mark.integration
def test_real_browserless_connection():
    """å®Ÿéš›ã®Browserlessæ¥ç¶šãƒ†ã‚¹ãƒˆ"""
    if not os.getenv("BROWSERLESS_TOKEN"):
        pytest.skip("BROWSERLESS_TOKEN not set")
    
    result = scrape_with_browserless("https://httpbin.org/html")
    assert result["status"] == "success"
```

## ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã¨ãƒ­ã‚®ãƒ³ã‚°

### æ§‹é€ åŒ–ãƒ­ã‚°

```python
import logging
import json
from typing import Dict, Any

def setup_scraping_logger() -> logging.Logger:
    """ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ç”¨ãƒ­ã‚¬ãƒ¼è¨­å®š"""
    logger = logging.getLogger("selenium_scraper")
    
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)
    
    return logger

def log_scraping_metrics(
    url: str, 
    duration: float, 
    status: str, 
    details: Dict[str, Any] = None
) -> None:
    """ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ãƒ­ã‚°"""
    metrics = {
        "url": url,
        "duration_seconds": duration,
        "status": status,
        "timestamp": time.time(),
        "details": details or {}
    }
    
    logger.info(f"Scraping metrics: {json.dumps(metrics)}")
```

## ãƒ‡ãƒãƒƒã‚°æ”¯æ´

### Browserless Live Debuggeræ´»ç”¨

```python
def create_debug_session(url: str) -> str:
    """Browserless Live Debuggerç”¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ"""
    debug_options = Options()
    debug_options.add_argument("--remote-debugging-port=9222")
    
    capabilities = DesiredCapabilities.CHROME
    capabilities['browserless:token'] = os.environ.get('BROWSERLESS_TOKEN')
    capabilities['browserless:debug'] = True
    
    driver = webdriver.Remote(
        command_executor="https://chrome.browserless.io/webdriver",
        options=debug_options,
        desired_capabilities=capabilities
    )
    
    # ãƒ‡ãƒãƒƒã‚°ç”¨URLç”Ÿæˆ
    session_id = driver.session_id
    debug_url = f"https://chrome.browserless.io/devtools/browser/{session_id}"
    
    print(f"Debug URL: {debug_url}")
    return debug_url
```

## ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 1. Driveré¸æŠã®åˆ¤æ–­åŸºæº–
- **Browserless**: æœ¬ç•ªç’°å¢ƒã€é«˜é »åº¦ã€ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ€§é‡è¦–
- **Local Driver**: é–‹ç™ºç’°å¢ƒã€ä½é »åº¦ã€ã‚³ã‚¹ãƒˆé‡è¦–

### 2. Railwayæœ€é©åŒ–
- **Private networkingæ´»ç”¨**: è¤‡æ•°ã‚µãƒ¼ãƒ“ã‚¹é–“é€šä¿¡
- **Environment variables**: è¨­å®šã®å¤–éƒ¨åŒ–
- **Resource limits**: é©åˆ‡ãªãƒªã‚½ãƒ¼ã‚¹åˆ¶é™è¨­å®š

### 3. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
- **Tokenç®¡ç†**: ç’°å¢ƒå¤‰æ•°ã§ã®ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†
- **ãƒ­ã‚°å‡ºåŠ›**: æ©Ÿå¯†æƒ…å ±ã®é™¤å¤–
- **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: è©³ç´°ã‚¨ãƒ©ãƒ¼æƒ…å ±ã®åˆ¶å¾¡
description:
globs:
alwaysApply: false
---
